<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>YGSA 매칭 미리보기</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css"
      crossorigin
    />
    <style>
      :root {
        font-family: 'Pretendard Variable', Pretendard, -apple-system, BlinkMacSystemFont, 'Segoe UI',
          'Apple SD Gothic Neo', 'Noto Sans KR', sans-serif;
        --ink: #0f172a;
        --ink-subtle: #475569;
        --line: rgba(15, 23, 42, 0.08);
        --success: #0f9d58;
        --danger: #dc2626;
      }

      * {
        box-sizing: border-box;
      }

      [hidden] {
        display: none !important;
      }

      body {
        margin: 0;
        min-height: 100vh;
        color: var(--ink);
      }

      main.apply-layout {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: clamp(20px, 3vw, 32px);
        box-sizing: border-box;
        padding: 24px 16px;
      }

      .hero {
        display: grid;
        gap: 24px;
        width: 100%;
        max-width: 420px;
        text-align: left;
        color: #4f4f4f;
        justify-items: stretch;
      }

      .hero-description {
        margin: 0;
        line-height: 1.6;
        font-size: 18px;
        color: #7e7e7e;
      }

      .results {
        width: 100%;
        max-width: 1200px;
      }

      .hero-eyebrow {
        font-size: 13px;
        letter-spacing: 0.3em;
        text-transform: uppercase;
        color: #a855f7;
        margin: 0;
      }

      .hero h1 {
        margin: 0;
        font-size: clamp(28px, 6vw, 44px);
        line-height: 1.2;
      }

      form.lookup-form {
        display: grid;
        gap: 16px;
        max-width: 420px;
        width: 100%;
        margin: 0 auto;
        justify-items: stretch;
      }

      .input-group {
        display: grid;
        gap: 8px;
        width: 100%;
        justify-items: start;
      }

      label {
        font-weight: 600;
        color: #7e7e7e;
        font-size: 18px;
        text-align: left;
      }

      input[type='tel'] {
        border: 1px solid var(--line);
        border-radius: 16px;
        padding: 16px 18px;
        font-size: 16px;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
        width: 100%;
      }

      input[type='tel']:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(147, 51, 234, 0.18);
      }

      button {
        border: none;
        border-radius: 16px;
        font-size: 16px;
        font-weight: 700;
        padding: 16px;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
        width: 100%;
      }

      button.primary {
        background: #5377f6;
        color: #fff;
        box-shadow: none;
      }

      button.primary:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        box-shadow: none;
      }

      button.primary:not(:disabled):hover {
        transform: translateY(-1px);
        background: #4c6fe0;
      }

      button.ghost {
        background: transparent;
        color: var(--ink-subtle);
        border: 1px solid rgba(148, 163, 184, 0.4);
      }

      .message {
        margin: 0;
        padding: 12px 14px;
        border-radius: 16px;
        font-size: 14px;
        line-height: 1.5;
        display: none;
      }

      .message.is-visible {
        display: block;
      }

      .message.is-error {
        background: rgba(220, 38, 38, 0.08);
        color: var(--danger);
      }

      .message.is-success {
        background: rgba(16, 185, 129, 0.12);
        color: #0f9d58;
      }

      .results-head {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        gap: 16px;
        margin-bottom: 24px;
      }

      .results-eyebrow {
        margin: 0;
        font-size: 16px;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        color: #5377f6;
        font-family: 'Pretendard Variable', Pretendard, -apple-system, BlinkMacSystemFont, 'Segoe UI',
          'Apple SD Gothic Neo', 'Noto Sans KR', sans-serif;
        font-weight: 500;
      }

      .results-head h2 {
        margin: 6px 0 4px;
        font-size: clamp(24px, 5vw, 36px);
        color: #4f4f4f;
        font-weight: 700;
      }

      .results-meta {
        margin: 0;
        color: #7e7e7e;
        font-size: 16px;
      }

      .matches-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 24px;
      }

      .match-card {
        position: relative;
        display: grid;
        gap: 18px;
        perspective: 1600px;
        overflow: visible;
        flex: 1 1 calc((100% - 48px) / 3);
        min-width: 260px;
        max-width: 360px;
      }

      .match-card-tagline {
        margin: 0;
        color: var(--ink-subtle);
        font-size: 14px;
        line-height: 1.6;
      }

      .profile-card-preview {
        width: 100%;
        aspect-ratio: 4 / 5;
        border-radius: 32px;
        border: 1px solid #f1f5f9;
        overflow: hidden;
        position: relative;
        background: linear-gradient(135deg, #f8fafc, #ffffff);
      }

      .profile-card-preview.profile-card-preview-female {
        border-color: #fecdd3;
        background: linear-gradient(135deg, #fff1f5, #ffe4e8);
      }

      .profile-card-preview.profile-card-preview-male {
        border-color: #bae6fd;
        background: linear-gradient(135deg, #ecfeff, #dbeafe);
      }

      .profile-card-slider {
        width: 100%;
        height: 100%;
        position: relative;
        opacity: 0;
        transform: rotateY(14deg) scale(0.96);
        filter: blur(4px) brightness(0.8);
        transition: opacity 500ms ease, transform 500ms ease, filter 500ms ease;
        visibility: hidden;
      }

      .match-card.is-open .profile-card-slider {
        opacity: 1;
        transform: rotateY(0deg) scale(1);
        filter: blur(0px) brightness(1);
        visibility: visible;
      }

      .match-card-cover {
        position: absolute;
        inset: 0;
        border-radius: 32px;
        background: radial-gradient(circle at top, rgba(83, 119, 246, 0.75), rgba(15, 23, 42, 0.95));
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        gap: 12px;
        cursor: pointer;
        z-index: 3;
        text-align: center;
        transition: opacity 350ms ease, transform 350ms ease;
        box-shadow: 0 20px 55px rgba(83, 119, 246, 0.4);
      }

      .match-card.match-card-incoming .match-card-cover {
        background: radial-gradient(circle at top, rgba(244, 114, 182, 0.85), rgba(190, 24, 93, 0.95));
        box-shadow: 0 20px 55px rgba(244, 114, 182, 0.4);
      }

      .match-card.match-card-extra .profile-card-preview {
        border-color: #f9a8d4;
        background: linear-gradient(135deg, rgba(252, 231, 243, 0.95), rgba(248, 181, 218, 0.9));
      }

      .match-card.match-card-extra .match-card-cover {
        background: radial-gradient(circle at top, rgba(244, 143, 177, 0.9), rgba(219, 39, 119, 0.9));
        box-shadow: 0 22px 60px rgba(244, 114, 182, 0.4);
      }

      .match-card-cover span {
        font-size: 18px;
        font-weight: 600;
      }

      .match-card-cover small {
        font-size: 12px;
        letter-spacing: 0.2em;
        opacity: 0.8;
      }

      .match-card.is-open .match-card-cover {
        opacity: 0;
        pointer-events: none;
        transform: scale(1.05);
      }

      .match-card-flash {
        position: absolute;
        inset: 0;
        border-radius: 32px;
        background: radial-gradient(circle, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0));
        opacity: 0;
        pointer-events: none;
        mix-blend-mode: screen;
      }

      .match-card.is-open .match-card-flash {
        animation: cardFlash 650ms ease-out;
      }

      @keyframes cardFlash {
        0% {
          opacity: 0.9;
          transform: scale(0.95);
        }
        60% {
          opacity: 0.3;
        }
        100% {
          opacity: 0;
          transform: scale(1.15);
        }
      }

      .match-card-crack {
        position: absolute;
        inset: 0;
        border-radius: 32px;
        pointer-events: none;
        opacity: 0;
        mix-blend-mode: screen;
        background-image: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0) 55%),
          repeating-conic-gradient(
            from 0deg,
            rgba(255, 255, 255, 0.45) 0deg 6deg,
            transparent 6deg 18deg
          );
        filter: blur(1px);
      }

      .match-card.is-open .match-card-crack {
        animation: crackBurst 700ms ease-out forwards;
      }

      @keyframes crackBurst {
        0% {
          opacity: 0;
          transform: scale(0.8) rotate(-6deg);
          filter: blur(6px);
        }
        40% {
          opacity: 0.9;
        }
        100% {
          opacity: 0;
          transform: scale(1.25) rotate(4deg);
          filter: blur(1px);
        }
      }

      .match-card-sparks {
        position: absolute;
        inset: 0;
        pointer-events: none;
        overflow: visible;
      }

      .match-card-sparks span {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 5px;
        height: 18px;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.95), rgba(83, 119, 246, 0));
        border-radius: 8px;
        transform-origin: center;
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.3);
        animation: sparkFly 720ms ease-out forwards;
        animation-delay: var(--delay, 0ms);
        animation-play-state: paused;
      }

      .match-card.is-open .match-card-sparks span {
        animation-play-state: running;
      }

      .match-card-actions {
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 12px;
        gap: 8px;
        flex-wrap: wrap;
        width: 100%;
      }

      .match-card-select-btn {
        border: 1px solid #5377f6;
        border-radius: 999px;
        padding: 12px 24px;
        font-size: 15px;
        font-weight: 600;
        background: #5377f6;
        color: #fff;
        cursor: pointer;
        box-shadow: none;
        transition: transform 0.2s ease, background 0.2s ease, border-color 0.2s ease;
        flex: 1 1 auto;
        width: auto;
        min-width: 0;
      }

      .match-card-select-btn:hover {
        transform: translateY(-1px);
        background: #4c6fe0;
        border-color: #4c6fe0;
      }

      .match-card-select-btn:focus-visible {
        outline: 3px solid rgba(83, 119, 246, 0.3);
        outline-offset: 3px;
      }

      .match-card-select-btn.is-completed {
        background: #e2e8f0;
        border-color: #e2e8f0;
        color: #6b7280;
        cursor: default;
        transform: none;
        box-shadow: none;
      }

      .match-card-select-btn.is-completed:hover {
        transform: none;
        background: #e2e8f0;
        border-color: #e2e8f0;
      }

      .match-card-select-btn.is-mutual {
        background: #16a34a;
        border-color: #15803d;
        color: #fff;
        cursor: pointer;
        box-shadow: 0 15px 30px rgba(22, 163, 74, 0.35);
      }

      .match-card-extra .match-card-select-btn {
        background: #f472b6;
        border-color: #ec4899;
        color: #fff;
        box-shadow: 0 12px 24px rgba(244, 114, 182, 0.35);
      }

      .match-card-extra .match-card-select-btn.is-mutual {
        background: #db2777;
        border-color: #be185d;
      }

      .match-card-select-btn.is-mutual:hover {
        background: #15803d;
        border-color: #166534;
      }

      .match-card-select-btn.incoming-select-btn {
        background: #f472b6;
        border-color: #ec4899;
        color: #fff;
        box-shadow: 0 12px 24px rgba(244, 114, 182, 0.35);
      }

      .match-card-select-btn.incoming-select-btn:hover {
        background: #ec4899;
        border-color: #db2777;
      }

      .match-card-cancel-btn {
        border-radius: 999px;
        padding: 8px 14px;
        font-size: 12px;
        font-weight: 600;
        background: #f8fafc;
        color: #64748b;
        border: 1px solid rgba(100, 116, 139, 0.3);
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
        width: auto;
        flex: 0 0 auto;
      }

      .match-card-cancel-btn:hover:not(:disabled) {
        background: #e2e8f0;
        color: #475569;
        border-color: rgba(71, 85, 105, 0.4);
      }

      .match-card-cancel-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .incoming-section {
        margin-top: 56px;
      }
      .incoming-divider {
        width: 100%;
        height: 1px;
        background: rgba(83, 119, 246, 0.2);
        margin-bottom: 16px;
      }
      .incoming-header {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
        margin-bottom: 28px;
        text-align: left;
      }

      .incoming-eyebrow {
        margin: 0;
        font-size: 16px;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        color: #5377f6;
        font-weight: 500;
      }

      .incoming-title-row {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 6px;
        text-align: left;
      }

      .incoming-title-row h3 {
        margin: 8px 0 0;
        font-size: clamp(24px, 5vw, 36px);
        color: #4f4f4f;
        font-weight: 700;
      }

      .incoming-subtitle {
        margin: 0;
        color: #7e7e7e;
        font-size: 16px;
      }

      .incoming-empty {
        margin: 0;
        padding-top: 8px;
        color: #94a3b8;
        font-size: 14px;
      }

      .contact-modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.55);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 4000;
        padding: 16px;
      }

      .contact-modal {
        background: #fff;
        border-radius: 28px;
        padding: 36px 40px;
        max-width: 400px;
        width: 100%;
        text-align: left;
        box-shadow: 0 35px 80px rgba(15, 23, 42, 0.25);
      }

      .contact-modal h3 {
        margin: 0 0 12px;
        font-size: 14px;
        color: #5377f6;
        font-weight: 600;
      }

      .contact-modal p {
        margin: 6px 0;
        font-size: 18px;
        color: #475569;
        text-align: left;
      }

      .contact-modal .contact-name {
        font-size: 18px;
        font-weight: 700;
        color: #4f4f4f;
      }

      .contact-modal .contact-phone {
        font-size: 18px;
        font-weight: 700;
        color: #4f4f4f;
      }

      .contact-modal .contact-guideline {
        margin-top: 18px;
        font-size: 15px;
        line-height: 1.6;
        color: #475569;
        text-align: left;
        white-space: pre-line;
      }

      .contact-modal button {
        margin-top: 24px;
        padding: 14px 22px;
        border-radius: 16px;
        border: none;
        background: #5377f6;
        color: #fff;
        font-size: 16px;
        cursor: pointer;
      }

      .contact-modal button:hover {
        background: #4c6fe0;
      }

      .match-popup-overlay {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.25);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
      }

      .match-popup {
        background: #fff;
        border-radius: 20px;
        padding: 28px 36px;
        box-shadow: 0 25px 60px rgba(15, 23, 42, 0.18);
        text-align: center;
        color: #4f4f4f;
        font-size: 18px;
        font-weight: 600;
      }

      @keyframes sparkFly {
        0% {
          opacity: 0;
          transform: translate(-50%, -50%) scale(0.3);
        }
        20% {
          opacity: 1;
        }
        100% {
          opacity: 0;
          transform: translate(
              calc(-50% + var(--sx, 0px)),
              calc(-50% + var(--sy, -80px))
            )
            scale(0.1)
            rotate(180deg);
        }
      }

      .profile-card-slide {
        position: absolute;
        inset: 0;
        opacity: 0;
        transition: opacity 0.35s ease;
        pointer-events: none;
      }

      .profile-card-slide.is-active {
        opacity: 1;
        pointer-events: auto;
      }

      .profile-card-slide-info {
        display: flex;
        width: 100%;
        height: 100%;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: thin;
        overscroll-behavior: contain;
        background: #ffffff;
      }

      /* 카드 내부 스크롤에서 오버스크롤 시 부모 배경이 비치며 색 번짐처럼 보이는 현상 방지 */
      .profile-card-preview.profile-card-preview-female .profile-card-slide-info {
        background: linear-gradient(135deg, #fff1f5, #ffe4e8);
      }

      .profile-card-preview.profile-card-preview-male .profile-card-slide-info {
        background: linear-gradient(135deg, #ecfeff, #dbeafe);
      }

      .profile-card-info {
        width: 100%;
        padding: 32px;
        background: linear-gradient(135deg, #f8fafc, #ffffff);
        border-radius: 32px;
        display: flex;
        flex-direction: column;
        gap: 18px;
        color: #0f172a;
        height: 100%;
        flex: 1 0 auto;
      }

      .profile-card-info-label {
        font-size: 11px;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: #94a3b8;
      }

      .profile-card-preview.profile-card-preview-female .profile-card-info {
        background: linear-gradient(135deg, #fff1f5, #ffe4e8);
        color: #8b1c3d;
      }

      .profile-card-preview.profile-card-preview-male .profile-card-info {
        background: linear-gradient(135deg, #ecfeff, #dbeafe);
        color: #0f4c81;
      }

      .profile-card-photo {
        position: relative;
        width: 100%;
        height: 100%;
        background: #020617;
      }

      .profile-card-photo img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }

      .profile-card-photo-label {
        position: absolute;
        bottom: 20px;
        left: 24px;
        padding: 6px 12px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.55);
        color: #f8fafc;
        font-size: 12px;
        letter-spacing: 0.12em;
        text-transform: uppercase;
      }

      .profile-card-slider-dots {
        position: absolute;
        bottom: 16px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;
        z-index: 2;
      }

      .profile-card-slider-controls {
        position: absolute;
        bottom: 70px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 16px;
        z-index: 2;
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transition: opacity 0.2s ease;
      }

      .profile-card-preview:hover .profile-card-slider-controls,
      .profile-card-preview:focus-within .profile-card-slider-controls {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
      }

      .profile-card-slider-arrow {
        width: 42px;
        height: 42px;
        border-radius: 50%;
        border: 1px solid rgba(248, 250, 252, 0.6);
        background: rgba(15, 23, 42, 0.35);
        color: #f8fafc;
        font-size: 24px;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }

      .profile-card-slider-dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        border: none;
        background: rgba(255, 255, 255, 0.35);
        cursor: pointer;
        padding: 0;
      }

      .profile-card-slider-dot.is-active {
        background: #ffffff;
      }

      .profile-card-info h2 {
        display: block;
        margin: 0;
        font-size: 26px;
        font-weight: 700;
        color: currentColor;
      }

      .profile-card-tagline {
        margin: 0;
        font-size: 14px;
        line-height: 1.6;
        color: #334155;
      }

      .profile-chip-row {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .profile-chip {
        border-radius: 999px;
        padding: 6px 12px;
        font-size: 12px;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        border: 1px solid #e2e8f0;
        background: #f8fafc;
        color: #0f172a;
      }

      .profile-chip.muted {
        color: #94a3b8;
        border-style: dashed;
      }

      .profile-card-preview-female .profile-chip {
        border-color: #fecdd3;
        background: rgba(244, 114, 182, 0.12);
        color: #be185d;
      }

      .profile-card-preview-male .profile-chip {
        border-color: #bae6fd;
        background: rgba(59, 130, 246, 0.12);
        color: #0f4c81;
      }

      .profile-card-stats {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 12px;
      }

      .profile-card-stat {
        display: flex;
        flex-direction: column;
        gap: 4px;
        padding: 10px 12px;
        border-radius: 16px;
        background: rgba(248, 250, 252, 0.85);
        border: 1px solid rgba(148, 163, 184, 0.3);
      }

      .profile-card-preview-female .profile-card-stat {
        background: rgba(244, 114, 182, 0.12);
        border-color: rgba(244, 114, 182, 0.45);
      }

      .profile-card-preview-male .profile-card-stat {
        background: rgba(59, 130, 246, 0.12);
        border-color: rgba(59, 130, 246, 0.45);
      }

      .profile-card-stat span {
        font-size: 10px;
        letter-spacing: 0.15em;
        text-transform: uppercase;
        color: #a0aec0;
      }

      .profile-card-stat strong {
        font-size: 16px;
        color: #475569;
      }

      .profile-card-lifestyle {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .profile-card-lifestyle .label {
        font-size: 11px;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: #94a3b8;
      }

      .profile-card-info-appeal {
        gap: 16px;
      }

      .profile-card-appeal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .profile-card-appeal-pill {
        padding: 4px 10px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.12);
        font-size: 11px;
        letter-spacing: 0.18em;
        text-transform: uppercase;
        color: #0f172a;
      }

      .profile-card-appeal-body {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .profile-card-appeal-block {
        padding: 0;
        border: none;
        border-radius: 0;
        background: transparent;
        width: 100%;
        text-align: left;
      }

      .profile-card-appeal-block + .profile-card-appeal-block {
        margin-top: 12px;
      }

      .profile-card-appeal-block .label {
        font-size: 11px;
        letter-spacing: 0.15em;
        text-transform: uppercase;
        color: #94a3b8;
        text-align: left;
        display: block;
      }

      .profile-card-appeal-block p {
        margin: 8px 0 0;
        font-size: 14px;
        line-height: 1.6;
        color: #0f172a;
        white-space: pre-line;
        text-align: left;
      }

      .profile-card-appeal-empty {
        margin: 0;
        font-size: 14px;
        color: #94a3b8;
      }

      @media (max-width: 720px) {
        body {
          padding: 16px;
        }
      }

      /* 페이지 오버스크롤(끝에서 튕길 때 나타나는 색 번짐/글로우) 최소화 */
      html,
      body {
        overscroll-behavior: none;
      }
    </style>
  </head>
  <body>
    <main class="apply-layout">
      <section class="hero">
        <div>
          <h1 style="margin:0 0 12px 0;font-size:36px;font-weight:700;color:#4f4f4f;">
            매칭 확인하기<span style="color:#5377f6;">.</span>
          </h1>
          <p class="hero-description">
            라운드 기준으로 가까운 수요일에 공개됩니다.<br />
            기본 3명, 상황에 따라 추가 제안이 열릴 수 있어요.
          </p>
        </div>
        <form id="lookupForm" class="lookup-form" novalidate>
          <div class="input-group">
            <label for="phoneInput" style="font-weight:400;color:#7e7e7e;font-size:18px;text-align:left;">
              상담 시 등록했던 휴대폰 번호를 입력해주세요
            </label>
            <input
              id="phoneInput"
              type="tel"
              inputmode="tel"
              autocomplete="tel"
              placeholder="예: 010-1111-1111"
              required
            />
          </div>
          <button type="submit" id="submitButton" class="primary">추천 카드 보기</button>
          <p id="formMessage" class="message" role="alert"></p>
        </form>
      </section>
      <section class="results" id="resultsSection" hidden>
        <div class="results-head">
          <div>
            <p class="results-eyebrow" id="weekLabel">이번 주 추천</p>
            <h2 id="resultTitle">회원님을 위한 추천</h2>
            <p class="results-meta" id="resultMeta"></p>
          </div>
        </div>
        <div class="matches-grid" id="matchCards"></div>
        <div class="incoming-section" id="incomingSection" hidden>
          <header class="incoming-header">
            <div class="incoming-divider"></div>
            <div class="incoming-title-row">
              <h3>나와 연결되고 싶은 사람</h3>
              <p class="incoming-subtitle">실시간 요청 카드</p>
            </div>
          </header>
          <div class="matches-grid" id="incomingCards"></div>
          <p class="incoming-empty" id="incomingEmpty">아직 도착한 실시간 요청 카드가 없습니다.</p>
        </div>
      </section>
    </main>
    <div class="contact-modal-overlay" id="contactModal" hidden>
      <div class="contact-modal" role="dialog" aria-modal="true">
        <h3>매칭 회원 정보</h3>
        <p class="contact-name" id="contactModalName">성함: -</p>
        <p class="contact-phone" id="contactModalPhone">휴대폰 번호: -</p>
        <p class="contact-guideline" id="contactModalMessage"></p>
        <button type="button" id="contactModalCloseBtn">확인</button>
      </div>
    </div>
    <script>
      window.BACKEND_ORIGIN = window.BACKEND_ORIGIN || 'https://ygsa-backend.onrender.com'
    </script>
    <script src="https://ygsa-backend.onrender.com/backend-config.js"></script>
    <script>
      ;(() => {
        const canvas = document.createElement('canvas')
        canvas.id = 'confettiCanvas'
        canvas.style.position = 'fixed'
        canvas.style.top = '0'
        canvas.style.left = '0'
        canvas.style.width = '100%'
        canvas.style.height = '100%'
        canvas.style.pointerEvents = 'none'
        canvas.style.zIndex = '9999'
        document.body.appendChild(canvas)

        const ctx = canvas.getContext('2d')
        const resize = () => {
          canvas.width = window.innerWidth
          canvas.height = window.innerHeight
        }
        resize()
        window.addEventListener('resize', resize)

        const colors = ['#ff6b6b', '#ffd93d', '#6bcbee', '#a26bff', '#4ade80']
        const particles = []
        const gravity = 0.12
        const drag = 0.98

        const createBurst = () => {
          const count = 160
          for (let i = 0; i < count; i += 1) {
            const angle = (Math.PI * 2 * i) / count + Math.random() * 0.3
            const speed = Math.random() * 8 + 4
            particles.push({
              x: canvas.width / 2,
              y: canvas.height * 0.35,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed - 2,
              size: Math.random() * 6 + 4,
              color: colors[Math.floor(Math.random() * colors.length)],
              rotation: Math.random() * Math.PI,
              rotationSpeed: (Math.random() - 0.5) * 0.2,
              life: 1,
            })
          }
        }

        let animationFrame
        const render = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height)
          particles.forEach((p) => {
            p.vx *= drag
            p.vy = p.vy * drag + gravity
            p.x += p.vx
            p.y += p.vy
            p.rotation += p.rotationSpeed
            p.life -= 0.005

            ctx.save()
            ctx.translate(p.x, p.y)
            ctx.rotate(p.rotation)
            ctx.globalAlpha = Math.max(p.life, 0)
            ctx.fillStyle = p.color
            ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 1.4)
            ctx.restore()
          })
          for (let i = particles.length - 1; i >= 0; i -= 1) {
            if (particles[i].life <= 0 || particles[i].y > canvas.height + 50) {
              particles.splice(i, 1)
            }
          }
          if (particles.length) {
            animationFrame = requestAnimationFrame(render)
          }
        }

        window.addEventListener('load', () => {
          createBurst()
          render()
          setTimeout(() => {
            cancelAnimationFrame(animationFrame)
            window.removeEventListener('resize', resize)
            canvas.remove()
          }, 3500)
        })
      })()
    </script>
    <script>
      ;(() => {
        const form = document.getElementById('lookupForm')
        const heroSection = document.querySelector('.hero')
        const phoneInput = document.getElementById('phoneInput')
        const submitButton = document.getElementById('submitButton')
        const messageEl = document.getElementById('formMessage')
        const resultsSection = document.getElementById('resultsSection')
        const resultTitle = document.getElementById('resultTitle')
        const resultMeta = document.getElementById('resultMeta')
        const weekLabel = document.getElementById('weekLabel')
        const matchCards = document.getElementById('matchCards')
        const incomingSection = document.getElementById('incomingSection')
        const incomingCards = document.getElementById('incomingCards')
        const incomingEmpty = document.getElementById('incomingEmpty')
        const contactModal = document.getElementById('contactModal')
        const contactModalName = document.getElementById('contactModalName')
        const contactModalPhone = document.getElementById('contactModalPhone')
        const contactModalMessage = document.getElementById('contactModalMessage')
        const contactModalCloseBtn = document.getElementById('contactModalCloseBtn')
        const MATCH_MANAGER_URL =
          (window.MATCH_MANAGER_URL && String(window.MATCH_MANAGER_URL).trim()) || ''
        const ADMIN_OVERRIDE_PHONES = null
        const FIRST_UNLOCK_TIMESTAMP = new Date('2025-12-03T10:00:00+09:00').getTime()
        const WEEK_INTERVAL_MS = 7 * 24 * 60 * 60 * 1000
        const UNLOCK_MESSAGE = '12월 3일 (수) 오전 10시부터 확인이 가능합니다.'
        const NEXT_UNLOCK_MESSAGE = '12월 10일 (수) 오전 10시부터 확인이 가능합니다.'
        const ACCESS_WINDOW_MS = 72 * 60 * 60 * 1000
        const ACCESS_GRANTS_STORAGE_KEY = 'match_access_grants_v1'
        let currentTargetProfile = null
        let matchPopupTimer = null
        let lastLookupPhoneKey = ''
        const matchedCandidateIds = new Set()
        const matchState = {
          incomingById: new Map(),
          incomingList: [],
          confirmedById: new Map(),
          contactById: new Map(),
          currentDeckIds: new Set(),
        }
        const realtimeState = {
          source: null,
          retryTimer: null,
          targetId: null,
        }
        const PENDING_SELECTIONS_STORAGE_KEY = 'match_pending_selections_v1'
        const INCOMING_REQUESTS_STORAGE_KEY = 'match_incoming_requests_v1'
        let currentWeekKey = ''
        let pendingSelectionSet = new Set()
        contactModalCloseBtn?.addEventListener('click', hideContactModal)
        contactModal?.addEventListener('click', (event) => {
          if (event.target === contactModal) {
            hideContactModal()
          }
        })
        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape' && contactModal && !contactModal.hidden) {
            hideContactModal()
          }
        })

        const resolvedOrigin =
          (typeof window !== 'undefined' && window.BACKEND_ORIGIN) ||
          (typeof location !== 'undefined' ? `${location.origin}` : '')
        const MATCH_HISTORY_ENDPOINT = (
          (MATCH_MANAGER_URL && MATCH_MANAGER_URL.trim()) ||
          `${(resolvedOrigin || '').replace(/\/$/, '') || ''}/api/match-history`
        ).replace(/\/$/, '')
        const MATCH_LOOKUP_URL = `${(resolvedOrigin || '').replace(/\/$/, '') || ''}/api/match-history/lookup`
        const EVENTS_URL = `${(resolvedOrigin || '').replace(/\/$/, '') || ''}/events`

        form?.addEventListener('submit', handleSubmit)
        checkInitialUnlockState()

        function getCurrentUnlockTime(now = Date.now()) {
          if (!Number.isFinite(FIRST_UNLOCK_TIMESTAMP)) return 0
          if (now < FIRST_UNLOCK_TIMESTAMP) {
            return FIRST_UNLOCK_TIMESTAMP
          }
          const weeksSinceFirst = Math.floor((now - FIRST_UNLOCK_TIMESTAMP) / WEEK_INTERVAL_MS)
          return FIRST_UNLOCK_TIMESTAMP + weeksSinceFirst * WEEK_INTERVAL_MS
        }

        function getNextUnlockMessage(now = Date.now()) {
          const currentUnlock = getCurrentUnlockTime(now)
          const nextUnlock = currentUnlock + WEEK_INTERVAL_MS
          const date = new Date(nextUnlock)
          const formatter = new Intl.DateTimeFormat('ko-KR', {
            month: 'long',
            day: 'numeric',
            weekday: 'short',
            hour: 'numeric',
            minute: 'numeric',
            hour12: false,
          })
          return `${formatter.format(date)}부터 확인이 가능합니다.`
        }

        function checkInitialUnlockState() {
          const now = Date.now()
          const unlockTime = getCurrentUnlockTime(now)
          if (unlockTime && now < unlockTime) {
            showMessage(UNLOCK_MESSAGE, true)
          }
        }

        function isAdminOverridePhone(phoneDigits) {
          return Boolean(String(phoneDigits || '').trim())
        }

        async function handleSubmit(event) {
          event.preventDefault()
          if (!phoneInput) return
          const phone = phoneInput.value.replace(/[^0-9]/g, '').trim()
          const isAdminOverride = isAdminOverridePhone(phone)
          if (!phone) {
            showMessage('전화번호를 입력해주세요.', true)
            return
          }
          const now = Date.now()
          const unlockTime = getCurrentUnlockTime(now)
          if (unlockTime && now < unlockTime && !isAdminOverride) {
            showMessage(UNLOCK_MESSAGE, true)
            return
          }
          if (!isAdminOverride) {
            const grant = loadAccessGrant(phone)
            if (grant && now - grant < ACCESS_WINDOW_MS) {
              // ok
            } else if (grant && now - grant >= ACCESS_WINDOW_MS) {
              showMessage(`이번주 소개 기간이 종료되었습니다. ${getNextUnlockMessage(now)}`, true)
              return
            } else {
              saveAccessGrant(phone, now)
            }
          }
          lastLookupPhoneKey = phone
          pendingSelectionSet = loadPendingSelections(lastLookupPhoneKey)
          setLoading(true)
          showMessage('')
          try {
            const payload = await fetchMatches(phone)
            renderMatches(payload)
            showMessage('')
          } catch (error) {
            console.error(error)
            showMessage(error?.message || '매칭 정보를 불러오지 못했습니다.', true)
            resultsSection.hidden = true
          } finally {
            setLoading(false)
          }
        }

        function setLoading(isLoading) {
          if (submitButton) {
            submitButton.disabled = Boolean(isLoading)
            submitButton.textContent = isLoading ? '불러오는 중...' : '추천 카드 보기'
          }
        }
        if (phoneInput) {
          phoneInput.addEventListener('input', () => {
            let digits = phoneInput.value.replace(/[^0-9]/g, '')
            if (digits.length < 4) {
              phoneInput.value = digits
              return
            }
            if (digits.length < 8) {
              phoneInput.value = digits.replace(/(\d{3})(\d+)/, '$1-$2')
              return
            }
            phoneInput.value = digits.replace(/(\d{3})(\d{3,4})(\d{0,4}).*/, '$1-$2-$3')
          })
        }

        async function fetchMatches(phone) {
          const response = await fetch(MATCH_LOOKUP_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ phone, limit: 3 }),
            cache: 'no-store',
          })
          let body = {}
          try {
            body = await response.json()
          } catch (_) {
            /* noop */
          }
          if (!response.ok || body?.ok === false) {
            const message = body?.message || '조회에 실패했습니다.'
            throw new Error(message)
          }
          return body?.data || {}
        }

        function getViewerCandidateKey() {
          return normalizeCandidateKey(currentTargetProfile?.id)
        }

        function renderMatches(data) {
          const matches = Array.isArray(data?.matches) ? data.matches : []
          const confirmedMatchCards = Array.isArray(data?.confirmedMatchCards)
            ? data.confirmedMatchCards
            : []
          const mergedMatches = mergeMatchesWithConfirmed(matches, confirmedMatchCards)
          syncMatchedCandidateIds(Array.isArray(data?.matchedCandidateIds) ? data.matchedCandidateIds : [])
          const weekInfo = data?.week || buildWeekMeta(new Date())
          currentWeekKey = buildWeekKey(weekInfo)
          const incomingRequestsRaw = Array.isArray(data?.incomingRequests) ? data.incomingRequests : []
          const persistedIncoming = loadStoredIncomingRequests(lastLookupPhoneKey, currentWeekKey)
          const incomingRequests = mergeIncomingRequests(incomingRequestsRaw, persistedIncoming)
          saveStoredIncomingRequests(lastLookupPhoneKey, currentWeekKey, incomingRequests)
          const matchedContacts = Array.isArray(data?.matchedCandidates) ? data.matchedCandidates : []
          const hasAnyCards = mergedMatches.length || matchedContacts.length
          if (!hasAnyCards) {
            resultsSection.hidden = true
            throw new Error('표시할 매칭 카드가 없습니다.')
          }
          syncMatchState({ incomingRequests, matchedCandidates: matchedContacts })
          cleanupPendingSelections()
          const targetName = data?.target?.name || '회원님'
          const nameWithHonorific = targetName.endsWith('님') ? targetName : `${targetName}님`
          resultTitle.textContent = `${nameWithHonorific}을 위한 추천`
          resultMeta.textContent = data?.target?.phoneMasked
            ? `${data.target.phoneMasked} 인증 완료`
            : ''
          weekLabel.textContent = weekInfo?.label || '이번 주 추천'
          currentTargetProfile = buildMatchTargetSnapshot(data?.target)
          ensureRealtimeConnection()

          matchCards.innerHTML = ''
          matchState.currentDeckIds = new Set()
          let pendingSelectionsDirty = false
          mergedMatches.forEach((record, index) => {
            const candidateId = getCandidateIdentifier(record)
            const incomingRequestForCard =
              candidateId && matchState.incomingById.has(candidateId)
                ? matchState.incomingById.get(candidateId)
                : null
            const incomingStatus = String(incomingRequestForCard?.status || '').toLowerCase()
            const isIncomingConfirmed = incomingStatus === 'confirmed'
            const isExtraMatch = Boolean(incomingRequestForCard && isIncomingConfirmed)
            if (candidateId) {
              matchState.currentDeckIds.add(candidateId)
            }
            const isServerRecordedSelection =
              candidateId &&
              Boolean(record?.targetSelected) &&
              !matchState.confirmedById.has(candidateId)
            if (isServerRecordedSelection && candidateId && pendingSelectionSet.delete(candidateId)) {
              pendingSelectionsDirty = true
            }
            const isPendingSelection =
              !matchState.confirmedById.has(candidateId) &&
              ((candidateId && pendingSelectionSet.has(candidateId)) || isServerRecordedSelection)
            const card = renderMatchCard(record, index + 1, {
              initialContact: matchState.confirmedById.get(candidateId),
              incomingRequest: incomingRequestForCard,
              pendingSelection: isPendingSelection,
              extraMatch: isExtraMatch,
            })
            if (card) {
              matchCards.appendChild(card)
            }
          })
          injectFallbackConfirmedCards(matchedContacts)
        function mergeMatchesWithConfirmed(matches = [], confirmedCards = []) {
          const merged = Array.isArray(matches) ? [...matches] : []
          const indexMap = new Map()
          merged.forEach((record, idx) => {
            const candidateId = getCandidateIdentifier(record)
            if (candidateId) {
              indexMap.set(candidateId, idx)
            }
          })
          confirmedCards.forEach((card) => {
            const candidateId = getCandidateIdentifier(card)
            if (!candidateId) return
            if (indexMap.has(candidateId)) {
              merged[indexMap.get(candidateId)] = { ...merged[indexMap.get(candidateId)], ...card }
            }
          })
          return merged
        }

          matchState.incomingList = incomingRequests
          renderIncomingRequests()
          if (heroSection) {
            heroSection.hidden = true
          }
          resultsSection.hidden = false
          if (pendingSelectionsDirty && lastLookupPhoneKey) {
            savePendingSelections(lastLookupPhoneKey, pendingSelectionSet)
          }
        }

        function syncMatchedCandidateIds(ids = []) {
          const viewerKey = getViewerCandidateKey()
          matchedCandidateIds.clear()
          ids
            .map((value) => (value == null ? '' : String(value).trim()))
            .filter(Boolean)
            .forEach((id) => {
              if (viewerKey && id === viewerKey) return
              matchedCandidateIds.add(id)
            })
        }

        function syncMatchState({ incomingRequests = [], matchedCandidates = [] } = {}) {
          const viewerKey = getViewerCandidateKey()
          matchState.incomingById.clear()
          matchState.contactById.clear()
          matchState.incomingList = Array.isArray(incomingRequests) ? incomingRequests : []
          matchState.incomingList.forEach((req) => {
            const requesterKey = normalizeCandidateKey(req?.requesterId)
            if (!requesterKey) return
            matchState.incomingById.set(requesterKey, req)
            if (req.contact) {
              matchState.contactById.set(requesterKey, {
                name: req.contact.name || '',
                phone: req.contact.phone || '',
                phoneMasked: req.contact.phoneMasked || '',
              })
            }
          })
          matchState.confirmedById.clear()
          matchedCandidates.forEach((entry) => {
            const candidateKey = normalizeCandidateKey(entry?.candidateId)
            if (!candidateKey) return
            if (viewerKey && candidateKey === viewerKey) return
            const contact = {
              name: entry.candidateName || '',
              phone: entry.candidatePhone || '',
              phoneMasked:
                entry.candidatePhoneMasked ||
                maskPhoneNumber(entry.candidatePhone || entry.candidatePhoneMasked || ''),
            }
            matchState.confirmedById.set(candidateKey, contact)
            matchState.contactById.set(candidateKey, contact)
          })
        }

        function buildContactSnapshot(source = {}, fallbackName = '') {
          if (!source) return null
          const normalizedPhone = normalizePhoneKey(source.phone || source.phoneNumber || '')
          const name = source.name || fallbackName || ''
          const phoneMasked =
            source.phoneMasked || (normalizedPhone ? maskPhoneNumber(normalizedPhone) : '')
          if (!name && !normalizedPhone && !phoneMasked) return null
          return {
            name,
            phone: normalizedPhone,
            phoneMasked,
          }
        }

        function renderIncomingRequests() {
          if (!incomingSection || !incomingCards) return
          const visible = []
          matchState.incomingList.forEach((req) => {
            const requesterKey = normalizeCandidateKey(req?.requesterId)
            if (!requesterKey) return
            const requestStatus = String(req?.status || '').toLowerCase()
            const isConfirmedIncoming = requestStatus === 'confirmed'
            const isInDeck = matchState.currentDeckIds.has(requesterKey)
            const isExtraIncoming = !isInDeck || Boolean(req?.extraMatch)
            if (!isConfirmedIncoming && matchState.currentDeckIds.has(requesterKey)) return
            if (!isConfirmedIncoming && matchState.confirmedById.has(requesterKey)) return
            // 이번주 소개(덱)에 이미 있는 후보가 "추가 매칭"이 아닌 상태로 확정되었다면
            // incoming 영역에서는 중복 노출하지 않는다.
            if (isConfirmedIncoming && isInDeck && !isExtraIncoming) return
            visible.push({ request: req, requesterKey, isConfirmedIncoming })
          })
          incomingCards.innerHTML = ''
          if (!visible.length) {
            incomingSection.hidden = true
            if (incomingEmpty) incomingEmpty.hidden = false
            return
          }
          incomingSection.hidden = false
          if (incomingEmpty) incomingEmpty.hidden = true
          visible.forEach(({ request, requesterKey, isConfirmedIncoming }) => {
            const profileRecord = {
              ...(request.profile || {}),
              id:
                (request.profile &&
                  normalizeCandidateKey(request.profile.id || request.profile.profileId)) ||
                requesterKey,
            }
            const candidateId = getCandidateIdentifier(profileRecord) || requesterKey
            const existingContact = matchState.contactById.get(candidateId)
            const contactFromRequest = buildContactSnapshot(
              request.contact,
              profileRecord.characterName || profileRecord.name || '',
            )
            if (!existingContact && contactFromRequest) {
              matchState.contactById.set(candidateId, contactFromRequest)
              matchState.contactById.set(requesterKey, contactFromRequest)
            }
            const initialContact =
              matchState.contactById.get(candidateId) ||
              matchState.contactById.get(requesterKey) ||
              contactFromRequest
            const isInDeck = matchState.currentDeckIds.has(requesterKey)
            const isExtraIncoming = !isInDeck || Boolean(request?.extraMatch)
            const card = renderMatchCard(profileRecord, null, {
              isIncomingOnly: true,
              coverTitle: isConfirmedIncoming
                ? isExtraIncoming
                  ? '추가 매칭 완료'
                  : '매칭 완료'
                : isExtraIncoming
                  ? '추가 매칭 카드'
                  : '실시간 요청',
              coverSubtitle: isConfirmedIncoming
                ? '이미 연결된 회원입니다'
                : '지금 확인하고 수락하세요',
              incomingRequest: request,
              initialContact,
              extraMatch: isExtraIncoming,
            })
            if (card) {
              incomingCards.appendChild(card)
            }
          })
        }

        function markIncomingRequestConfirmed(candidateKey, request, contactInfo) {
          if (!candidateKey) return
          const normalizedKey = normalizeCandidateKey(candidateKey)
          const existingRequest = request || matchState.incomingById.get(normalizedKey)
          if (!existingRequest) return
          const updated = {
            ...existingRequest,
            status: 'confirmed',
            contact: contactInfo || existingRequest.contact || null,
            extraMatch: true,
          }
          matchState.incomingById.set(normalizedKey, updated)
          const listIndex = matchState.incomingList.findIndex(
            (entry) => normalizeCandidateKey(entry?.requesterId) === normalizedKey,
          )
          if (listIndex !== -1) {
            matchState.incomingList[listIndex] = updated
          } else {
            matchState.incomingList.unshift(updated)
          }
          persistIncomingRequestUpdate(normalizedKey, updated)
          renderIncomingRequests()
        }

        function isExtraMatchCandidate(candidateId) {
          const key = normalizeCandidateKey(candidateId)
          if (!key) return false
          const req = matchState.incomingById.get(key)
          if (!req) return false
          if (req.extraMatch !== undefined) {
            return Boolean(req.extraMatch)
          }
          return String(req?.status || '').toLowerCase() === 'confirmed'
        }

        async function recordMutualMatchForRequester(incomingRequest, primaryPayload) {
          if (!incomingRequest || !currentTargetProfile?.id) return
          const requesterId = normalizeCandidateKey(incomingRequest.requesterId)
          const viewerId = normalizeCandidateKey(currentTargetProfile.id)
          if (!requesterId || !viewerId) return
          const contactSource =
            incomingRequest.contact ||
            matchState.contactById.get(requesterId) ||
            buildContactSnapshot(
              {
                phone: incomingRequest.profile?.phone,
                phoneMasked: incomingRequest.profile?.phoneMasked,
              },
              incomingRequest.profile?.characterName || incomingRequest.profile?.name || '',
            )
          const targetPhone = normalizePhoneKey(
            contactSource?.phone || contactSource?.phoneMasked || '',
          )
          if (!targetPhone) return
          const viewerPhone = normalizePhoneKey(
            currentTargetProfile.phone ||
              currentTargetProfile.phoneMasked ||
              lastLookupPhoneKey ||
              '',
          )
          const matchedAt = primaryPayload?.matchedAt || Date.now()
          const payload = {
            id: `${requesterId}-${viewerId}-${matchedAt}-mutual`,
            candidateId: viewerId,
            targetId: requesterId,
            targetPhone,
            matchedAt,
            week: buildWeekMeta(new Date(matchedAt)),
            category: 'confirmed',
            candidateName: currentTargetProfile.name || '',
            candidateGender: currentTargetProfile.gender || '',
            candidatePhone: viewerPhone,
            targetName:
              contactSource?.name ||
              incomingRequest.profile?.characterName ||
              incomingRequest.profile?.name ||
              '',
            targetGender: incomingRequest.profile?.gender || '',
            targetSelected: true,
          }
          try {
            await sendMatchRequest(payload)
          } catch (error) {
            console.warn('[match-select] mutual record failed', error)
          }
        }

        function deriveCandidateKey(entry = {}) {
          return (
            normalizeCandidateKey(
              entry?.candidateId ||
                entry?.matchCandidateId ||
                entry?.id ||
                entry?.profileId ||
                '',
            ) || normalizePhoneKey(entry?.candidatePhone || '')
          )
        }

        function injectFallbackConfirmedCards(matchedContacts = []) {
          if (!Array.isArray(matchedContacts) || !matchedContacts.length) return
          const viewerKey = getViewerCandidateKey()
          matchedContacts.forEach((entry) => {
            const candidateId = deriveCandidateKey(entry)
            if (!candidateId || matchState.currentDeckIds.has(candidateId)) return
            if (viewerKey && candidateId === viewerKey) return
            // "나와 연결되고 싶은 사람(incoming)"으로 들어온 확정 카드는 추천 카드 영역으로 끌어올리지 않는다.
            // (새로고침 시에도 추가 매칭 완료 카드는 incoming 섹션에 유지)
            if (matchState.incomingById.has(candidateId)) return
            const fallbackRecord = buildFallbackConfirmedRecord(entry, candidateId)
            if (!fallbackRecord) return
            matchState.currentDeckIds.add(candidateId)
            const cardElement = renderMatchCard(fallbackRecord, null, {
              coverTitle: '확정 카드',
              coverSubtitle: '이미 매칭되었습니다',
              initialContact: matchState.confirmedById.get(candidateId),
            })
            if (cardElement) {
              matchCards.appendChild(cardElement)
            }
          })
        }

        function buildFallbackConfirmedRecord(entry, candidateId) {
          if (!candidateId) return null
          const matchedAt = Number(entry?.matchedAt)
          const resolvedMatchedAt =
            Number.isFinite(matchedAt) && matchedAt > 0 ? matchedAt : Date.now()
          const fallbackName = entry?.candidateName || '확정 매칭 카드'
          const phone = entry?.candidatePhone || ''
          const phoneMasked = entry?.candidatePhoneMasked || maskPhoneNumber(phone)
          return {
            id: candidateId,
            candidateId,
            characterName: fallbackName,
            name: fallbackName,
            phone,
            phoneNumber: phone,
            phoneMasked,
            matchRecordedAt: resolvedMatchedAt,
            matchCandidateId: candidateId,
            matchCategory: 'confirmed',
            matchEntryId: `${candidateId}-${resolvedMatchedAt}-fallback`,
            photos: [],
            preferredLifestyle: [],
            profileAppeal: entry?.profileAppeal || '',
            profileSummary: entry?.profileSummary || '',
          }
        }

        function renderMatchCard(record, order, options = {}) {
          if (!record) return null
          const {
            isIncomingOnly = false,
            coverTitle = null,
            coverSubtitle = null,
            incomingRequest = null,
            initialContact = null,
            pendingSelection = false,
            extraMatch = false,
          } = options
          const wrapper = document.createElement('article')
          wrapper.className = ['match-card', isIncomingOnly ? 'match-card-incoming' : '']
            .filter(Boolean)
            .join(' ')
          if (extraMatch) {
            wrapper.classList.add('match-card-extra')
          }
          wrapper.tabIndex = 0
          const candidateId = getCandidateIdentifier(record)
          const matchEntryId = record.matchEntryId || incomingRequest?.requestId || ''
          const preview = document.createElement('div')
          const toneClass = getProfileToneClass(record.gender)
          preview.className = `profile-card-preview ${toneClass}`.trim()
          preview.innerHTML = renderProfileCard(record)
          const cover = document.createElement('div')
          cover.className = 'match-card-cover'
          const coverTitleText =
            coverTitle || (extraMatch ? '추가 매칭' : order ? `매칭 ${order || ''}` : '추천 카드')
          const coverSubtitleText =
            coverSubtitle ||
            (extraMatch
              ? '추가 매칭 완료'
              : order
                ? '카드를 펼쳐 확인하세요'
                : '지금 확인해보세요')
          cover.innerHTML = `
            <span>${escapeHtml(coverTitleText)}</span>
            <small>${escapeHtml(coverSubtitleText)}</small>
          `
          const flash = document.createElement('div')
          flash.className = 'match-card-flash'
          const crack = document.createElement('div')
          crack.className = 'match-card-crack'
          const sparks = document.createElement('div')
          sparks.className = 'match-card-sparks'
          const sparkCount = 10
          for (let i = 0; i < sparkCount; i += 1) {
            const span = document.createElement('span')
            const angle = (Math.PI * 2 * i) / sparkCount + Math.random() * 0.3
            const distance = 140 + Math.random() * 60
            span.style.setProperty('--sx', `${Math.cos(angle) * distance}px`)
            span.style.setProperty('--sy', `${Math.sin(angle) * distance}px`)
            span.style.setProperty('--delay', `${i * 35}ms`)
            span.style.transform = `rotate(${(angle * 180) / Math.PI}deg)`
            sparks.appendChild(span)
          }
          preview.appendChild(cover)
          preview.appendChild(flash)
          preview.appendChild(crack)
          preview.appendChild(sparks)
          wrapper.appendChild(preview)
          const { actions, selectButton: actionButton, cancelButton } = createMatchCardActions(
            record,
            candidateId,
            matchEntryId,
            {
              isIncomingOnly,
            },
          )
          hydrateMatchButtonMetadata(actionButton, record)
          if (initialContact) {
            setButtonContactData(actionButton, initialContact)
          }
          if (pendingSelection && !matchState.confirmedById.has(candidateId)) {
            markMatchButtonCompleted(actionButton, { mutual: false, cancelButton, extraMatch })
            revealMatchCard(wrapper)
          }
          if (
            matchState.confirmedById.has(candidateId) ||
            matchedCandidateIds.has(candidateId) ||
            (record.matchCategory && String(record.matchCategory).toLowerCase() === 'confirmed')
          ) {
            markMatchButtonCompleted(actionButton, {
              mutual: true,
              contact: matchState.contactById.get(candidateId) || initialContact || getContactInfo(candidateId),
              cancelButton,
              extraMatch,
            })
            revealMatchCard(wrapper)
          }
          preview.insertAdjacentElement('afterend', actions)
          initProfileCardSlider(preview)
          applyMatchedCardState(wrapper, actionButton, cancelButton, candidateId, record.matchCategory)
          setupCardReveal(wrapper)
          return wrapper
        }
        function applyMatchedCardState(wrapper, button, cancelButton, candidateId, category) {
          if (!wrapper || !button) return
          const candidateKey = normalizeCandidateKey(candidateId)
          const normalizedCategory = String(category || '').trim().toLowerCase()
          const alreadyMatched =
            normalizedCategory === 'confirmed' || (candidateKey && matchedCandidateIds.has(candidateKey))
          if (!alreadyMatched) return
          const contactInfo = getContactInfo(candidateKey)
          const extraMatch = isExtraMatchCandidate(candidateKey)
          if (extraMatch) {
            wrapper.classList.add('match-card-extra')
          }
          markMatchButtonCompleted(button, {
            mutual: true,
            contact: contactInfo,
            cancelButton,
            extraMatch,
          })
          revealMatchCard(wrapper)
        }


        function showMessage(text, isError = false) {
          if (!messageEl) return
          if (!text) {
            messageEl.textContent = ''
            messageEl.classList.remove('is-visible', 'is-error', 'is-success')
            return
          }
          messageEl.textContent = text
          messageEl.classList.add('is-visible')
          messageEl.classList.toggle('is-error', Boolean(isError))
          messageEl.classList.toggle('is-success', !isError)
        }

        function getProfileToneClass(gender) {
          if (!gender) return ''
          const normalized = String(gender).trim()
          if (/여|female|woman/i.test(normalized)) return 'profile-card-preview-female'
          if (/남|male|man/i.test(normalized)) return 'profile-card-preview-male'
          return ''
        }

        const PROFILE_CARD_CHARACTER_NAMES = [
          '루나',
          '카이',
          '아린',
          '라온',
          '세라',
          '레온',
          '이든',
          '소라',
          '리안',
          '제이드',
          '하린',
          '도윤',
          '미카',
          '유나',
          '지안',
          '네로',
          '하루',
          '라일라',
          '준호',
          '세이',
        ]

        const SALARY_RANGE_LABELS = {
          '1': '3000만원 미만',
          '2': '3000-4000만원',
          '3': '4000-6000만원',
          '4': '6000-8000만원',
          '5': '8000-1억원',
          '6': '1-2억원',
          '7': '2-3억원',
          '8': '3억원 이상',
        }

        const profileCardNameCache = new WeakMap()

        function renderProfileCard(record) {
          const slides = buildProfileCardSlides(record)
          const slideCount = slides.length || 1
          return `
            <div class="profile-card-slider" data-profile-card-slider data-slide-count="${slideCount}">
              ${slides
                .map(
                  (slide, index) => `
                  <div class="profile-card-slide ${slide.className} ${index === 0 ? 'is-active' : ''}" data-profile-card-slide data-slide-index="${index}">
                    ${slide.content}
                  </div>
                `,
                )
                .join('')}
              ${slideCount > 1 ? renderProfileCardSliderExtras(slideCount) : ''}
            </div>
          `
        }

        function buildProfileCardSlides(record) {
          const slides = []
          const facePhotos = getProfileCardPhotos(record, 'face')
          facePhotos.forEach((photo, index) => {
            slides.push({
              className: 'profile-card-slide-photo',
              content: renderProfileCardPhotoSlide(photo, `얼굴 사진 ${index + 1}`),
            })
          })
          const fullPhotos = getProfileCardPhotos(record, 'full')
          fullPhotos.forEach((photo, index) => {
            slides.push({
              className: 'profile-card-slide-photo',
              content: renderProfileCardPhotoSlide(photo, `전신 사진 ${index + 1}`),
            })
          })
          const infoContent = renderProfileCardInfoSection(record)
          if (infoContent) {
            slides.push({ className: 'profile-card-slide-info', content: infoContent })
          }
          const appealContent = renderProfileCardAppealSection(record)
          if (appealContent) {
            slides.push({
              className: 'profile-card-slide-info profile-card-slide-appeal',
              content: appealContent,
            })
          }
          return slides
        }

        function renderProfileCardSliderExtras(count) {
          return `
            <div class="profile-card-slider-controls" role="group" aria-label="슬라이드 제어">
              <button type="button" class="profile-card-slider-arrow profile-card-slider-arrow-prev" data-slide-action="prev" aria-label="이전 슬라이드">‹</button>
              <button type="button" class="profile-card-slider-arrow profile-card-slider-arrow-next" data-slide-action="next" aria-label="다음 슬라이드">›</button>
            </div>
            <div class="profile-card-slider-dots" data-profile-card-dots role="tablist">
              ${Array.from({ length: count })
                .map(
                  (_, index) => `
                  <button type="button" class="profile-card-slider-dot ${index === 0 ? 'is-active' : ''}" data-slide-to="${index}" aria-label="${index + 1}번째 슬라이드 보기"></button>
                `,
                )
                .join('')}
            </div>
          `
        }

        function renderProfileCardPhotoSlide(photo, fallbackLabel) {
          if (!photo?.source) return ''
          const label = fallbackLabel || photo.label || '프로필 사진'
          return `
            <div class="profile-card-photo">
              <img src="${escapeHtml(photo.source)}" alt="${escapeHtml(label)}" loading="lazy" />
              <span class="profile-card-photo-label">${escapeHtml(label)}</span>
            </div>
          `
        }

        function createMatchCardActions(record, candidateId, matchEntryId, options = {}) {
          const actions = document.createElement('div')
          actions.className = 'match-card-actions'
          const selectButton = createMatchSelectButton(record, candidateId, matchEntryId, options)
          const cancelButton = createMatchCancelButton(selectButton)
          actions.appendChild(selectButton)
          actions.appendChild(cancelButton)
          return { actions, selectButton, cancelButton }
        }

        function createMatchSelectButton(record, candidateId, matchEntryId, options = {}) {
          const button = document.createElement('button')
          button.type = 'button'
          button.className = 'match-card-select-btn'
          if (options.isIncomingOnly) {
            button.classList.add('incoming-select-btn')
            button.textContent = '매칭 수락하기'
          } else {
            button.textContent = '매칭 선택하기'
          }
          const targetReady = Boolean(currentTargetProfile)
          const candidateKey = normalizeCandidateKey(candidateId)
          if (candidateKey) {
            button.dataset.candidateId = candidateKey
          }
          if (matchEntryId) {
            button.dataset.matchEntryId = String(matchEntryId)
          }
          if (!targetReady || !candidateKey) {
            button.disabled = true
            button.title = '추천 대상 정보를 찾을 수 없습니다.'
          }
          button.addEventListener('click', (event) => {
            event.stopPropagation()
            handleCardMatchSelect(record, button, candidateId, matchEntryId)
          })
          return button
        }

        function createMatchCancelButton(selectButton) {
          const button = document.createElement('button')
          button.type = 'button'
          button.className = 'match-card-cancel-btn'
          button.textContent = '취소하기'
          button.hidden = true
          button.addEventListener('click', (event) => {
            event.stopPropagation()
            const candidateKey = selectButton?.dataset?.candidateId || ''
            handlePendingMatchCancel(selectButton, candidateKey)
          })
          return button
        }

        function hydrateMatchButtonMetadata(button, record = {}) {
          if (!button || !record) return
          const displayName = record.characterName || record.name || ''
          if (displayName) {
            button.dataset.candidateName = displayName
          }
          if (record.gender) {
            button.dataset.candidateGender = record.gender
          }
          const phone = record.phone || record.phoneNumber || ''
          if (phone) {
            button.dataset.candidatePhone = phone
          }
          const matchedAtCandidates = [
            Number(record.matchRecordedAt),
            Number(record.matchedAt),
          ].filter((value) => Number.isFinite(value) && value > 0)
          if (matchedAtCandidates.length) {
            button.dataset.matchRecordedAt = String(matchedAtCandidates[0])
          }
        }

        function buildButtonRecordSnapshot(button) {
          if (!button) return null
          const phone = button.dataset.candidatePhone || ''
          const matchedAt = Number(button.dataset.matchRecordedAt)
          return {
            id: button.dataset.candidateId || '',
            name: button.dataset.candidateName || '',
            characterName: button.dataset.candidateName || '',
            gender: button.dataset.candidateGender || '',
            phone,
            phoneNumber: phone,
            matchRecordedAt: Number.isFinite(matchedAt) && matchedAt > 0 ? matchedAt : undefined,
          }
        }

        async function handleCardMatchSelect(record, button, candidateIdOverride, matchEntryId) {
          if (!button) return
          const fallbackRecord =
            record ||
            matchState.incomingById.get(getCandidateIdentifier(record)) ||
            matchState.confirmedById.get(getCandidateIdentifier(record)) ||
            {}
          const candidateId =
            candidateIdOverride ||
            getCandidateIdentifier(record) ||
            getCandidateIdentifier(fallbackRecord)
          if (!candidateId) {
            showMessage('매칭 정보를 찾을 수 없습니다.', true)
            return
          }
          const currentState = button.dataset.matchState
          if (currentState === 'mutual') {
            const contact = getButtonContactData(button)
            showContactModal(contact)
            return
          }
          if (currentState === 'completed' || currentState === 'requesting') {
            return
          }
          const cancelButton = getCancelButton(button)
          const originalScrollY = window.scrollY || document.documentElement.scrollTop || 0
          const originalButtonTop = button?.getBoundingClientRect()?.top || 0
          const candidateKey = normalizeCandidateKey(candidateId)
          const incomingRequest = matchState.incomingById.get(candidateKey)
          const resolvedMatchEntryId = matchEntryId || incomingRequest?.requestId || ''
          const hasIncomingRequest = Boolean(incomingRequest)
          const isInDeck = candidateKey ? matchState.currentDeckIds.has(candidateKey) : false
          // "추가 매칭"은 상대가 나를 선택한 요청이 있으면서(=incoming) 이번주 소개 덱에는 없을 때만
          const isExtraMatch = hasIncomingRequest && !isInDeck
          const payload = buildMatchSelectionPayload(record, candidateId, resolvedMatchEntryId, {
            categoryOverride: incomingRequest ? 'confirmed' : 'intro',
            extraMatch: isExtraMatch,
          })
          if (!payload) {
            showMessage('매칭 정보를 준비할 수 없습니다. 관리자에게 문의해주세요.', true)
            return
          }
          button.dataset.matchState = 'requesting'
          button.disabled = true
          if (cancelButton) {
            cancelButton.disabled = true
          }
          try {
            await sendMatchRequest(payload)
            let contactInfo = hasIncomingRequest ? getContactInfo(candidateKey) : null
            if (!contactInfo && hasIncomingRequest && incomingRequest?.contact) {
              contactInfo = buildContactSnapshot(
                incomingRequest.contact,
                button.dataset.candidateName || record?.characterName || record?.name || '',
              )
              if (contactInfo) {
                matchState.contactById.set(candidateKey, contactInfo)
              }
            }
            markMatchButtonCompleted(button, {
              mutual: hasIncomingRequest,
              contact: hasIncomingRequest ? contactInfo : null,
              cancelButton,
              matchEntryId: payload.id,
              extraMatch: isExtraMatch,
            })
            if (hasIncomingRequest) {
              matchedCandidateIds.add(candidateKey)
              markIncomingRequestConfirmed(candidateKey, incomingRequest, contactInfo)
              await recordMutualMatchForRequester(incomingRequest, payload)
              if (pendingSelectionSet.delete(candidateKey)) {
                savePendingSelections(lastLookupPhoneKey, pendingSelectionSet)
              }
            } else if (candidateKey) {
              if (!pendingSelectionSet.has(candidateKey)) {
                pendingSelectionSet.add(candidateKey)
                savePendingSelections(lastLookupPhoneKey, pendingSelectionSet)
              }
            }
            window.requestAnimationFrame(() => {
              window.scrollTo(0, originalScrollY)
              const newButtonTop = button?.getBoundingClientRect()?.top || originalButtonTop
              const delta = newButtonTop - originalButtonTop
              if (Math.abs(delta) > 1) {
                window.scrollBy(0, delta)
              }
            })
          } catch (error) {
            console.error('[match-select] 전송 실패', error)
            showMessage(error?.message || '매칭 신청을 전송하지 못했습니다.', true)
          } finally {
            if (button.dataset.matchState === 'requesting') {
              button.dataset.matchState = ''
              button.disabled = false
            }
            if (cancelButton && !hasIncomingRequest) {
              cancelButton.disabled = false
            }
          }
        }

        async function handlePendingMatchCancel(button, candidateId) {
          if (!button) return
          const cancelButton = getCancelButton(button)
          if (!cancelButton) return
          if (button.dataset.matchState === 'requesting' || button.dataset.matchState === 'cancelling') {
            return
          }
          const candidateKey = normalizeCandidateKey(candidateId || button.dataset.candidateId)
          if (!candidateKey) {
            showMessage('취소할 매칭 정보를 찾을 수 없습니다.', true)
            return
          }
          const matchEntryId = button.dataset.matchEntryId || ''
          const snapshot = buildButtonRecordSnapshot(button)
          const payload = buildMatchSelectionPayload(snapshot, candidateKey, matchEntryId, {
            categoryOverride: 'intro',
            targetSelectedOverride: false,
            matchedAtOverride: snapshot?.matchRecordedAt || Date.now(),
          })
          if (!payload) {
            showMessage('취소할 매칭 정보를 준비하지 못했습니다.', true)
            return
          }
          button.dataset.matchState = 'cancelling'
          cancelButton.disabled = true
          try {
            await sendMatchRequest(payload)
            if (candidateKey && pendingSelectionSet.delete(candidateKey)) {
              savePendingSelections(lastLookupPhoneKey, pendingSelectionSet)
            }
            resetMatchButtonState(button)
            showMessage('매칭 신청이 취소되었습니다.')
          } catch (error) {
            console.error('[match-cancel] 취소 실패', error)
            showMessage(error?.message || '매칭 신청을 취소하지 못했습니다.', true)
          } finally {
            if (button.dataset.matchState === 'cancelling') {
              button.dataset.matchState = ''
            }
            cancelButton.disabled = false
          }
        }

        function resetMatchButtonState(button) {
          if (!button) return
          button.classList.remove('is-completed', 'is-mutual')
          button.disabled = false
          button.dataset.matchState = ''
          button.textContent = button.classList.contains('incoming-select-btn')
            ? '매칭 수락하기'
            : '매칭 선택하기'
          clearButtonContactData(button)
          delete button.dataset.matchEntryId
          const cancelButton = getCancelButton(button)
          if (cancelButton) {
            cancelButton.hidden = true
            cancelButton.disabled = false
          }
        }

        function getCancelButton(button) {
          if (!button) return null
          return (
            button.closest('.match-card-actions')?.querySelector('.match-card-cancel-btn') || null
          )
        }

        function buildMatchSelectionPayload(
          record,
          candidateIdArg,
          matchEntryId,
          options = {},
        ) {
          if (!record || !currentTargetProfile || !lastLookupPhoneKey) return null
          const candidateId = candidateIdArg || getCandidateIdentifier(record)
          const targetId = currentTargetProfile.id || ''
          if (!candidateId || !targetId) return null
          const matchedAtOverride = Number(options?.matchedAtOverride)
          const resolvedMatchedAt =
            Number.isFinite(matchedAtOverride) && matchedAtOverride > 0
              ? matchedAtOverride
              : typeof record?.matchRecordedAt === 'number' && record.matchRecordedAt > 0
                ? record.matchRecordedAt
                : typeof record?.matchedAt === 'number' && record.matchedAt > 0
                  ? record.matchedAt
                  : Date.now()
          const normalizedCandidateKey = normalizeCandidateKey(candidateId)
          const contactFallback =
            normalizedCandidateKey && matchState.contactById.has(normalizedCandidateKey)
              ? matchState.contactById.get(normalizedCandidateKey)
              : null
          const candidatePhone = normalizePhoneKey(
            record.phone ||
              record.phoneNumber ||
              contactFallback?.phone ||
              contactFallback?.phoneMasked ||
              '',
          )
          const candidateName =
            record.name || record.characterName || contactFallback?.name || '추천 후보'
          const candidateGender = record.gender || ''
          const targetName = currentTargetProfile.name || '회원님'
          const targetGender = currentTargetProfile.gender || ''
          const normalizedCategory =
            String(options?.categoryOverride || 'confirmed').trim().toLowerCase() === 'confirmed'
              ? 'confirmed'
              : 'intro'
          const extraMatch = Boolean(options?.extraMatch)
          return {
            id: matchEntryId || `${targetId}-${candidateId}-${resolvedMatchedAt}`,
            candidateId,
            targetId,
            targetPhone: lastLookupPhoneKey,
            matchedAt: resolvedMatchedAt,
            week: buildWeekMeta(new Date(resolvedMatchedAt)),
            category: normalizedCategory,
            candidateName,
            candidateGender,
            candidatePhone,
            targetName,
            targetGender,
            targetSelected:
              options?.targetSelectedOverride !== undefined
                ? Boolean(options.targetSelectedOverride)
                : true,
            extraMatch,
          }
        }

        async function sendMatchRequest(payload) {
          const response = await fetch(MATCH_HISTORY_ENDPOINT, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload),
            mode: 'cors',
          })
          if (!response.ok) {
            const message = await response
              .json()
              .then((body) => body?.message)
              .catch(() => '')
            throw new Error(message || '매칭 기록을 저장하지 못했습니다.')
          }
        }

        function normalizeCandidateKey(value) {
          if (value === null || value === undefined) return ''
          return String(value).trim()
        }

        function getCandidateIdentifier(record) {
          if (!record) return ''
          const raw =
            record.id ??
            record.uuid ??
            record.candidateId ??
            record.matchCandidateId ??
            record.profileId ??
            record.requesterId ??
            record.phone ??
            record.phoneNumber ??
            record.phoneMasked ??
            record.phoneNumberMasked ??
            record.key ??
            ''
          return normalizeCandidateKey(raw) || normalizePhoneKey(raw)
        }

        function buildMatchTargetSnapshot(target) {
          if (!target) return null
          const phone = target.phone || target.phoneNumber || ''
          const fallbackId =
            target.id ||
            target.uuid ||
            target.profileId ||
            target.phone ||
            target.phoneNumber ||
            target.phoneMasked ||
            target.key ||
            ''
          const normalizedId = normalizeCandidateKey(fallbackId) || normalizePhoneKey(phone || target.phoneMasked || '')
          return {
            id: normalizedId,
            name: target.name || '회원님',
            gender: target.gender || '',
            phone,
            phoneMasked: target.phoneMasked || '',
            job: target.job || '',
            height: normalizeHeightValue(target.height) || '',
          }
        }


        function markMatchButtonCompleted(
          button,
          { mutual = false, contact = null, cancelButton = null, matchEntryId = '', extraMatch = false } = {},
        ) {
          if (!button) return
          if (matchEntryId) {
            button.dataset.matchEntryId = String(matchEntryId)
          }
          const inlineCancelButton = cancelButton || getCancelButton(button)
          button.classList.add('is-completed')
          button.classList.toggle('is-mutual', Boolean(mutual))
          button.classList.toggle('is-extra', Boolean(extraMatch))
          if (mutual) {
            button.disabled = false
            button.dataset.matchState = 'mutual'
            button.textContent = extraMatch ? '추가 매칭 완료. 정보 확인' : '매칭 완료. 정보 확인'
            if (contact) {
              setButtonContactData(button, contact)
            }
            if (inlineCancelButton) {
              inlineCancelButton.hidden = true
              inlineCancelButton.disabled = false
            }
          } else {
            button.disabled = true
            button.dataset.matchState = 'completed'
            button.textContent = extraMatch ? '추가 매칭이 신청되었습니다' : '매칭이 신청되었습니다'
            clearButtonContactData(button)
            if (inlineCancelButton) {
              inlineCancelButton.hidden = false
              inlineCancelButton.disabled = false
            }
          }
        }

        function setButtonContactData(button, contact = {}) {
          if (!button) return
          button.dataset.contactName = contact.name || ''
          button.dataset.contactPhone = contact.phone || ''
          button.dataset.contactPhoneMasked = contact.phoneMasked || ''
        }

        function clearButtonContactData(button) {
          if (!button) return
          delete button.dataset.contactName
          delete button.dataset.contactPhone
          delete button.dataset.contactPhoneMasked
        }

        function loadAccessGrant(phoneKey) {
          if (!phoneKey) return null
          try {
            const raw = localStorage.getItem(ACCESS_GRANTS_STORAGE_KEY)
            if (!raw) return null
            const parsed = JSON.parse(raw)
            const grant = parsed?.[phoneKey]
            return typeof grant === 'number' && Number.isFinite(grant) ? grant : null
          } catch (error) {
            console.warn('[match:access] 불러오기 실패', error)
            return null
          }
        }

        function saveAccessGrant(phoneKey, timestamp) {
          if (!phoneKey || !Number.isFinite(timestamp)) return
          try {
            const raw = localStorage.getItem(ACCESS_GRANTS_STORAGE_KEY)
            const data = raw ? JSON.parse(raw) : {}
            data[phoneKey] = timestamp
            localStorage.setItem(ACCESS_GRANTS_STORAGE_KEY, JSON.stringify(data))
          } catch (error) {
            console.warn('[match:access] 저장 실패', error)
          }
        }

        function revealMatchCard(wrapper) {
          if (!wrapper) return
          wrapper.classList.add('is-open')
          const cover = wrapper.querySelector('.match-card-cover')
          if (cover) {
            cover.style.opacity = '0'
            cover.style.pointerEvents = 'none'
          }
        }

        function loadPendingSelections(phoneKey) {
          if (!phoneKey) return new Set()
          try {
            const raw = localStorage.getItem(PENDING_SELECTIONS_STORAGE_KEY)
            if (!raw) return new Set()
            const parsed = JSON.parse(raw)
            const list = Array.isArray(parsed?.[phoneKey]) ? parsed[phoneKey] : []
            const normalized = list
              .map((value) => normalizeCandidateKey(value))
              .filter((value) => Boolean(value))
            return new Set(normalized)
          } catch (error) {
            console.warn('[match:pending] 불러오기 실패', error)
            return new Set()
          }
        }

        function savePendingSelections(phoneKey, set) {
          if (!phoneKey) return
          try {
            const raw = localStorage.getItem(PENDING_SELECTIONS_STORAGE_KEY)
            const data = raw ? JSON.parse(raw) : {}
            const normalized = Array.from(set)
              .map((value) => normalizeCandidateKey(value))
              .filter((value) => Boolean(value))
            data[phoneKey] = normalized
            localStorage.setItem(PENDING_SELECTIONS_STORAGE_KEY, JSON.stringify(data))
          } catch (error) {
            console.warn('[match:pending] 저장 실패', error)
          }
        }

        function loadStoredIncomingRequests(phoneKey, weekKey) {
          if (!phoneKey || !weekKey) return []
          try {
            const raw = localStorage.getItem(INCOMING_REQUESTS_STORAGE_KEY)
            if (!raw) return []
            const parsed = JSON.parse(raw)
            const bucket = parsed?.[phoneKey]
            if (!bucket || bucket.weekKey !== weekKey || !Array.isArray(bucket.requests)) return []
            return bucket.requests
          } catch (error) {
            console.warn('[match:incoming] 불러오기 실패', error)
            return []
          }
        }

        function saveStoredIncomingRequests(phoneKey, weekKey, requests = []) {
          if (!phoneKey || !weekKey) return
          try {
            const raw = localStorage.getItem(INCOMING_REQUESTS_STORAGE_KEY)
            const parsed = raw ? JSON.parse(raw) : {}
            parsed[phoneKey] = {
              weekKey,
              savedAt: Date.now(),
              requests: Array.isArray(requests) ? requests : [],
            }
            localStorage.setItem(INCOMING_REQUESTS_STORAGE_KEY, JSON.stringify(parsed))
          } catch (error) {
            console.warn('[match:incoming] 저장 실패', error)
          }
        }

        function mergeIncomingRequests(primary = [], fallback = []) {
          if (!primary.length && !fallback.length) return []
          const map = new Map()
          const push = (request) => {
            if (!request) return
            const key =
              normalizeCandidateKey(request.requesterId) ||
              normalizeCandidateKey(request.candidateId) ||
              normalizeCandidateKey(request.profile?.id) ||
              request.requestId ||
              `${map.size}`
            const existing = map.get(key)
            if (!existing || (request.requestRecordedAt || 0) > (existing.requestRecordedAt || 0)) {
              map.set(key, request)
            }
          }
          primary.forEach(push)
          fallback.forEach(push)
          return Array.from(map.values())
        }

        function persistIncomingRequestUpdate(requesterKey, updated) {
          if (!lastLookupPhoneKey || !currentWeekKey || !requesterKey) return
          const stored = loadStoredIncomingRequests(lastLookupPhoneKey, currentWeekKey)
          if (!stored.length) return
          const normalizedKey = normalizeCandidateKey(requesterKey)
          const next = stored.map((entry) => {
            const key =
              normalizeCandidateKey(entry?.requesterId) ||
              normalizeCandidateKey(entry?.candidateId) ||
              ''
            if (key !== normalizedKey) return entry
            return { ...entry, ...updated }
          })
          saveStoredIncomingRequests(lastLookupPhoneKey, currentWeekKey, next)
        }

        function cleanupPendingSelections() {
          if (!lastLookupPhoneKey || !pendingSelectionSet.size) return
          let changed = false
          matchState.confirmedById.forEach((_, candidateId) => {
            if (pendingSelectionSet.delete(candidateId)) {
              changed = true
            }
          })
          if (changed) {
            savePendingSelections(lastLookupPhoneKey, pendingSelectionSet)
          }
        }

        function getButtonContactData(button) {
          if (!button) return null
          const stored = {
            name: button.dataset.contactName || '',
            phone: button.dataset.contactPhone || '',
            phoneMasked: button.dataset.contactPhoneMasked || '',
          }
          if (stored.phone || stored.phoneMasked) {
            return stored
          }
          const fallbackPhone = button.dataset.candidatePhone || ''
          return {
            name: stored.name || button.dataset.candidateName || '',
            phone: fallbackPhone,
            phoneMasked: fallbackPhone
              ? maskPhoneNumber(fallbackPhone)
              : stored.phoneMasked || '',
          }
        }

        function showMatchConfirmationPopup() {
          let overlay = document.getElementById('matchSelectionPopup')
          if (!overlay) {
            overlay = document.createElement('div')
            overlay.id = 'matchSelectionPopup'
            overlay.className = 'match-popup-overlay'
            const popup = document.createElement('div')
            popup.className = 'match-popup'
            popup.textContent = '매칭이 신청되었습니다!'
            overlay.appendChild(popup)
            overlay.addEventListener('click', hideMatchConfirmationPopup)
            document.body.appendChild(overlay)
          } else {
            overlay.querySelector('.match-popup').textContent = '매칭이 신청되었습니다!'
          }
          overlay.hidden = false
          if (matchPopupTimer) {
            window.clearTimeout(matchPopupTimer)
          }
          matchPopupTimer = window.setTimeout(hideMatchConfirmationPopup, 1800)
        }

        function hideMatchConfirmationPopup() {
          const overlay = document.getElementById('matchSelectionPopup')
          if (!overlay) return
          overlay.hidden = true
          if (matchPopupTimer) {
            window.clearTimeout(matchPopupTimer)
            matchPopupTimer = null
          }
        }

        function buildWeekMeta(date) {
          const info = getWeekInfo(date)
          return {
            label: info.label,
            startTime: info.start.getTime(),
            endTime: info.end.getTime(),
            year: info.year,
            week: info.week,
          }
        }

        function buildWeekKey(week) {
          if (!week || typeof week !== 'object') return ''
          const year = Number(week.year)
          const weekNo = Number(week.week)
          if (!Number.isFinite(year) || !Number.isFinite(weekNo)) return ''
          return `${year}-W${String(weekNo).padStart(2, '0')}`
        }

        function getWeekInfo(date) {
          const target = new Date(date)
          const day = target.getDay() || 7
          const start = new Date(target)
          start.setHours(0, 0, 0, 0)
          start.setDate(start.getDate() - (day - 1))
          const end = new Date(start)
          end.setDate(start.getDate() + 6)

          const utcDate = new Date(Date.UTC(target.getFullYear(), target.getMonth(), target.getDate()))
          const utcDay = utcDate.getUTCDay() || 7
          utcDate.setUTCDate(utcDate.getUTCDate() + 4 - utcDay)
          const isoYear = utcDate.getUTCFullYear()
          const yearStart = new Date(Date.UTC(isoYear, 0, 1))
          const weekNo = Math.ceil(((utcDate - yearStart) / 86400000 + 1) / 7)

          return {
            year: isoYear,
            week: weekNo,
            label: `${isoYear}년 ${String(weekNo).padStart(2, '0')}주차`,
            start,
            end,
          }
        }

        function renderProfileCardInfoSection(record) {
          if (!record) return ''
          const chips =
            getProfileCardChips(record)
              .map((chip) => `<span class="profile-chip">${escapeHtml(chip)}</span>`)
              .join('') || '<span class="profile-chip muted">정보 준비 중</span>'
          const stats =
            getProfileCardStats(record)
              .map(
                ({ label, value }) => `
                  <div class="profile-card-stat">
                    <span>${escapeHtml(label)}</span>
                    <strong>${escapeHtml(value || '-')}</strong>
                  </div>
                `,
              )
              .join('') || `
              <div class="profile-card-stat">
                <span>INFO</span>
                <strong>업데이트 예정</strong>
              </div>
            `
          const lifestyle =
            getProfileCardLifestyle(record)
              .map((item) => `<span class="profile-chip">${escapeHtml(item)}</span>`)
              .join('') || '<span class="profile-chip muted">라이프스타일 업데이트 예정</span>'
          return `
            <div class="profile-card-info">
              <span class="profile-card-info-label">회원 정보</span>
              <h2>${escapeHtml(getProfileCardDisplayName(record))}</h2>
              <p class="profile-card-tagline">${escapeHtml(getProfileCardTagline(record))}</p>
              <div class="profile-chip-row">${chips}</div>
              <div class="profile-card-stats">${stats}</div>
              <div class="profile-card-lifestyle">
                <span class="label">선호 라이프스타일</span>
                <div class="profile-chip-row">${lifestyle}</div>
              </div>
            </div>
          `
        }

        function renderProfileCardAppealSection(record) {
          const blocks = getProfileCardAppealBlocks(record)
          const body =
            blocks.length > 0
              ? blocks
                  .map(
                    ({ label, value }) => `
                <section class="profile-card-appeal-block">
                  <span class="label">${escapeHtml(label)}</span>
                  <p>${formatProfileCardAppealValue(value)}</p>
                </section>
              `,
                  )
                  .join('')
              : `<p class="profile-card-appeal-empty">추가 어필 정보가 준비 중입니다.</p>`
          return `
            <div class="profile-card-info profile-card-info-appeal">
              <div class="profile-card-appeal-header">
                <span class="profile-card-info-label">추가 어필</span>
                <span class="profile-card-appeal-pill">연결사 추천</span>
              </div>
              <div class="profile-card-appeal-body">
                ${body}
              </div>
            </div>
          `
        }

        function getProfileCardDisplayName(record) {
          if (!record || typeof record !== 'object') return '연결사 회원'
          if (record.characterName) return record.characterName
          if (profileCardNameCache.has(record)) {
            return profileCardNameCache.get(record)
          }
          const seedSource =
            record.id ||
            record.uuid ||
            record.key ||
            record.phoneNumber ||
            record.phone ||
            record.email ||
            record.createdAt
          const alias = getRandomProfileCardName(seedSource)
          profileCardNameCache.set(record, alias)
          return alias
        }

        function getRandomProfileCardName(seedSource) {
          const pool = Array.isArray(PROFILE_CARD_CHARACTER_NAMES)
            ? PROFILE_CARD_CHARACTER_NAMES
            : []
          if (!pool.length) return '연결사 회원'
          if (seedSource !== undefined && seedSource !== null) {
            const seedString = String(seedSource).trim()
            if (seedString) {
              const hash = seedString.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0)
              return pool[hash % pool.length]
            }
          }
          const randomIndex = Math.floor(Math.random() * pool.length)
          return pool[randomIndex]
        }

        function getProfileCardTagline(record) {
          if (record?.profileAppeal) return record.profileAppeal
          if (record?.aboutMe) return record.aboutMe
          if (record?.sufficientCondition) return record.sufficientCondition
          return '연결사가 엄선한 프리미엄 인연'
        }

        function getProfileCardAppealBlocks(record) {
          if (!record) return []
          const blocks = []
          const addBlock = (label, value) => {
            const text = typeof value === 'string' ? value.trim() : ''
            if (!text) return
            blocks.push({ label, value: text })
          }
          if (record.profileAppeal || record.aboutMe || record.sufficientCondition) {
            addBlock('대표 어필', getProfileCardTagline(record))
          }
          addBlock('충분 조건', record.sufficientCondition)
          addBlock('필수 조건', record.necessaryCondition)
          addBlock('선호 / 비선호', record.likesDislikes)
          const values = Array.isArray(record.values) ? record.values.filter(Boolean) : []
          if (values.length) {
            addBlock('가치관', values.join(' · '))
          }
          addBlock('가치관 (기타)', record.valuesCustom)
          addBlock('자기 소개', record.aboutMe)
          addBlock('노트', record.notes)
          return blocks
        }

        function formatProfileCardAppealValue(value) {
          const safe = typeof value === 'string' ? value : String(value || '')
          return escapeHtml(safe).replace(/\n/g, '<br />')
        }

        function getProfileCardChips(record) {
          const chips = []
          if (record?.job) chips.push(record.job)
          if (record?.education) chips.push(record.education)
          if (record?.district) chips.push(record.district)
          if (record?.university) chips.push(record.university)
          return chips.slice(0, 3)
        }

        function getProfileCardStats(record) {
          if (!record) return []
          const stats = [
            { label: 'BIRTH', value: formatProfileBirthLabel(record.birth) },
            { label: 'HEIGHT', value: normalizeHeightValue(record.height || record.region) || '-' },
            { label: 'CAREER', value: record.job || '-' },
            { label: 'MBTI', value: (record.mbti || '-').toUpperCase() },
          ]
          const salaryLabel = formatSalaryRange(record.salaryRange)
          const universityLabel =
            typeof record.university === 'string' ? record.university.trim() : ''
          if (salaryLabel) {
            stats.push({ label: 'SALARY', value: salaryLabel })
            if (universityLabel) {
              stats.push({ label: 'UNIV', value: universityLabel })
            }
          } else if (record.education) {
            stats.push({ label: 'EDU', value: record.education })
            if (universityLabel) {
              stats.push({ label: 'UNIV', value: universityLabel })
            }
          } else if (universityLabel) {
            stats.push({ label: 'UNIV', value: universityLabel })
          }
          return stats
        }

        function getProfileCardLifestyle(record) {
          if (!record) return []
          const preferred = Array.isArray(record.preferredLifestyle)
            ? record.preferredLifestyle.filter(Boolean)
            : []
          if (preferred.length) {
            return preferred.slice(0, 3)
          }
          if (record.likesDislikes) {
            return record.likesDislikes
              .split(/[,·]/)
              .map((value) => value.trim())
              .filter(Boolean)
              .slice(0, 3)
          }
          return []
        }

        function formatProfileBirthLabel(value) {
          const digits = String(value || '').replace(/[^0-9]/g, '')
          if (digits.length >= 4) {
            return `${digits.slice(0, 4)}`
          }
          return value || '-'
        }

        function normalizeHeightValue(raw) {
          const digits = String(raw || '').replace(/[^0-9]/g, '').slice(0, 3)
          return digits ? `${digits}cm` : ''
        }

        function normalizePhoneKey(value) {
          return String(value || '').replace(/[^0-9]/g, '')
        }

        function maskPhoneNumber(value) {
          const digits = String(value || '').replace(/[^0-9]/g, '')
          if (!digits) return ''
          if (digits.length <= 4) return digits
          const head = digits.slice(0, 3)
          const tail = digits.slice(-4)
          const middle = '*'.repeat(Math.max(3, digits.length - 7))
          return `${head}-${middle}-${tail}`
        }

        function formatPhoneDisplay(value) {
          const digits = String(value || '').replace(/[^0-9]/g, '')
          if (!digits) return value || ''
          if (digits.length === 11) {
            return `${digits.slice(0, 3)}-${digits.slice(3, 7)}-${digits.slice(7)}`
          }
          if (digits.length === 10) {
            return `${digits.slice(0, 3)}-${digits.slice(3, 6)}-${digits.slice(6)}`
          }
          if (digits.length === 9) {
            return `${digits.slice(0, 2)}-${digits.slice(2, 5)}-${digits.slice(5)}`
          }
          return digits.replace(/(\d{3,4})(?=\d)/g, '$1-')
        }

        function getContactInfo(candidateId) {
          const key = normalizeCandidateKey(candidateId)
          if (!key) return null
          return matchState.contactById.get(key) || null
        }

        function showContactModal(contact = {}) {
          if (!contactModal || !contactModalName || !contactModalPhone || !contactModalMessage) return
          const name = contact.name || '상대 이름'
          const phoneRaw = contact.phone || contact.phoneMasked || '비공개'
          const phone = formatPhoneDisplay(phoneRaw)
          contactModalName.textContent = `성함: ${name}`
          contactModalPhone.textContent = `휴대폰 번호: ${phone}`
          contactModalMessage.textContent = buildContactGuidelineMessage()
          contactModal.hidden = false
          launchContactCelebration()
        }

        function hideContactModal() {
          if (!contactModal) return
          contactModal.hidden = true
        }

        function buildContactGuidelineMessage() {
          const maleMessage =
            '이후 남성 회원님께서 직접 연락하여 만남 일정과 장소를 조율해 주세요.\n\n남성 회원은 상호 매칭 성사 후 24시간 이내, 늦어도 다음날 21:00까지 반드시 첫 연락을 진행해 주세요.'
          const femaleMessage =
            '이후 남성 회원이 먼저 연락드릴 예정이니, 확인 후 연락처 저장 부탁드립니다.\n\n남성 회원의 첫 연락은 상호 매칭 성사 후 24시간 이내, 늦어도 다음날 21:00까지 진행됩니다.'
          const gender = String(currentTargetProfile?.gender || '').trim()
          if (/남|male|man/i.test(gender)) return maleMessage
          if (/여|female|woman/i.test(gender)) return femaleMessage
          return femaleMessage
        }

        function launchContactCelebration() {
          const canvas = document.createElement('canvas')
          canvas.style.position = 'fixed'
          canvas.style.top = '0'
          canvas.style.left = '0'
          canvas.style.width = '100%'
          canvas.style.height = '100%'
          canvas.style.pointerEvents = 'none'
          canvas.style.zIndex = '4500'
          document.body.appendChild(canvas)

          const ctx = canvas.getContext('2d')
          const colors = ['#fcd34d', '#fb7185', '#34d399', '#60a5fa', '#c084fc']
          const gravity = 0.15
          const drag = 0.985
          const particles = []

          function resize() {
            canvas.width = window.innerWidth
            canvas.height = window.innerHeight
          }

          resize()
          window.addEventListener('resize', resize)

          for (let i = 0; i < 160; i += 1) {
            const angle = (Math.PI * 2 * i) / 40 + Math.random() * 0.5
            const speed = Math.random() * 8 + 4
            particles.push({
              x: canvas.width / 2,
              y: canvas.height * 0.3,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              size: Math.random() * 6 + 4,
              color: colors[Math.floor(Math.random() * colors.length)],
              alpha: 1,
              rotation: Math.random() * Math.PI,
              rotationSpeed: (Math.random() - 0.5) * 0.2,
            })
          }

          let animationId
          const duration = 2500
          const startTime = performance.now()

          function render(now) {
            ctx.clearRect(0, 0, canvas.width, canvas.height)
            particles.forEach((p) => {
              p.vx *= drag
              p.vy = p.vy * drag + gravity
              p.x += p.vx
              p.y += p.vy
              p.rotation += p.rotationSpeed
              p.alpha -= 0.006

              ctx.save()
              ctx.translate(p.x, p.y)
              ctx.rotate(p.rotation)
              ctx.globalAlpha = Math.max(p.alpha, 0)
              ctx.fillStyle = p.color
              ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 1.6)
              ctx.restore()
            })
            if (now - startTime < duration) {
              animationId = requestAnimationFrame(render)
            } else {
              cleanup()
            }
          }

          function cleanup() {
            cancelAnimationFrame(animationId)
            window.removeEventListener('resize', resize)
            canvas.remove()
          }

          animationId = requestAnimationFrame(render)
          setTimeout(cleanup, duration + 500)
        }

        function formatSalaryRange(value) {
          return SALARY_RANGE_LABELS[value] || ''
        }

        function getProfileCardPhotos(record, preferredType) {
          if (!record) return []
          const normalized = preferredType === 'full' ? 'full' : 'face'
          const photos = Array.isArray(record.photos) ? record.photos : []
          const seen = new Set()
          return photos
            .map((photo) => {
              const role = getProfilePhotoRole(photo)
              if (!isProfilePhotoRoleMatch(role, normalized)) return null
              const source = getFileSource(photo)
              if (!source || seen.has(source)) return null
              seen.add(source)
              return { source, label: photo.name || '' }
            })
            .filter(Boolean)
        }

        function getProfilePhotoRole(photo) {
          const meta = photo?.meta || {}
          return String(
            photo?.role || meta.type || meta.category || meta.tag || meta.label || '',
          )
            .trim()
            .toLowerCase()
        }

        function isProfilePhotoRoleMatch(role, preferredType) {
          if (!role) return false
          if (preferredType === 'full') {
            return /full|body|전신/.test(role)
          }
          return /face|프로필|상반|portrait/.test(role)
        }

        function initProfileCardSlider(previewEl) {
          if (!previewEl) return
          const slider = previewEl.querySelector('[data-profile-card-slider]')
          if (!slider || slider.dataset.initialized === 'true') return
          slider.dataset.initialized = 'true'
          slider.dataset.currentIndex = '0'
          slider.tabIndex = 0
          slider.addEventListener('click', handleProfileCardSliderClick)
          slider.addEventListener('keydown', handleProfileCardSliderKeydown)
        }

        function setupCardReveal(card) {
          if (!card) return
          const cover = card.querySelector('.match-card-cover')
          const openCard = () => {
            if (card.classList.contains('is-open')) return
            card.classList.add('is-open')
          }
          if (cover) {
            cover.addEventListener('click', (event) => {
              event.stopPropagation()
              openCard()
            })
          }
          card.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
              event.preventDefault()
              openCard()
            }
          })
        }

        function handleProfileCardSliderClick(event) {
          const slider = event.currentTarget
          const dot = event.target.closest('[data-slide-to]')
          if (dot) {
            event.stopPropagation()
            setProfileCardSliderIndex(slider, Number(dot.dataset.slideTo || 0))
            return
          }
          const arrow = event.target.closest('[data-slide-action]')
          if (arrow) {
            event.stopPropagation()
            const action = arrow.dataset.slideAction
            advanceProfileCardSlider(slider, action === 'prev' ? -1 : 1)
            return
          }
          const interactive = event.target.closest('button, a')
          if (interactive && !interactive.dataset.slideTo && !interactive.dataset.slideAction) return
          const rect = slider.getBoundingClientRect?.()
          if (rect && Number.isFinite(rect.width) && rect.width > 0) {
            const clickX = event.clientX ?? rect.left
            const relativeX = clickX - rect.left
            const goPrev = relativeX < rect.width / 2
            advanceProfileCardSlider(slider, goPrev ? -1 : 1)
          } else {
            advanceProfileCardSlider(slider)
          }
        }

        function handleProfileCardSliderKeydown(event) {
          if (event.key === 'ArrowRight') {
            event.preventDefault()
            advanceProfileCardSlider(event.currentTarget, 1)
            return
          }
          if (event.key === 'ArrowLeft') {
            event.preventDefault()
            advanceProfileCardSlider(event.currentTarget, -1)
            return
          }
          if (event.key === ' ' || event.key === 'Enter') {
            event.preventDefault()
            advanceProfileCardSlider(event.currentTarget, 1)
          }
        }

        function advanceProfileCardSlider(slider, step = 1) {
          if (!slider) return
          const slides = slider.querySelectorAll('[data-profile-card-slide]')
          const count = slides.length
          if (!count) return
          const current = Number(slider.dataset.currentIndex || 0)
          const next = (current + step + count) % count
          setProfileCardSliderIndex(slider, next)
        }

        function setProfileCardSliderIndex(slider, index) {
          if (!slider) return
          const slides = slider.querySelectorAll('[data-profile-card-slide]')
          const dots = slider.querySelectorAll('[data-slide-to]')
          const count = slides.length
          if (!count) return
          const nextIndex = Math.max(0, Math.min(count - 1, Number(index) || 0))
          slides.forEach((slide, idx) => {
            slide.classList.toggle('is-active', idx === nextIndex)
          })
          dots.forEach((dot) => {
            dot.classList.toggle('is-active', Number(dot.dataset.slideTo) === nextIndex)
          })
          slider.dataset.currentIndex = String(nextIndex)
        }

        function getFileSource(fileData) {
          if (!fileData) return ''
          if (typeof fileData === 'string') return fileData
          if (typeof fileData.dataUrl === 'string' && fileData.dataUrl.trim()) return fileData.dataUrl.trim()
          if (typeof fileData.downloadURL === 'string' && fileData.downloadURL.trim())
            return fileData.downloadURL.trim()
          if (typeof fileData.url === 'string' && fileData.url.trim()) return fileData.url.trim()
          if (typeof fileData.src === 'string' && fileData.src.trim()) return fileData.src.trim()
          if (typeof fileData.data === 'string' && fileData.data.trim()) {
            const data = fileData.data.trim()
            if (data.startsWith('data:')) return data
            const mime =
              typeof fileData.type === 'string' && fileData.type.trim()
                ? fileData.type.trim()
                : 'application/octet-stream'
            return `data:${mime};base64,${data}`
          }
          if (typeof fileData.base64 === 'string' && fileData.base64.trim()) {
            const mime =
              typeof fileData.type === 'string' && fileData.type.trim()
                ? fileData.type.trim()
                : 'application/octet-stream'
            return `data:${mime};base64,${fileData.base64.trim()}`
          }
          return ''
        }

        function ensureRealtimeConnection() {
          if (typeof window === 'undefined') return
          if (!currentTargetProfile?.id) return
          const targetId = String(currentTargetProfile.id)
          if (realtimeState.targetId && realtimeState.targetId !== targetId) {
            teardownRealtimeConnection()
          }
          realtimeState.targetId = targetId
          if (realtimeState.retryTimer) {
            window.clearTimeout(realtimeState.retryTimer)
            realtimeState.retryTimer = null
          }
          if (realtimeState.source || typeof window.EventSource === 'undefined') return
          try {
            const source = new EventSource(EVENTS_URL)
            realtimeState.source = source
            source.addEventListener('message', handleRealtimeEvent)
            source.addEventListener('error', handleRealtimeError)
          } catch (error) {
            console.warn('[match:sse] 연결에 실패했습니다.', error)
            scheduleRealtimeRetry()
          }
        }

        function handleRealtimeEvent(event) {
          if (!event?.data) return
          let payload
          try {
            payload = JSON.parse(event.data)
          } catch (error) {
            console.warn('[match:sse] 이벤트 파싱 실패', error)
            return
          }
          if (payload?.type === 'match:confirmed') {
            handleRealtimeMatchConfirmed(payload.payload)
          }
        }

        function handleRealtimeError() {
          scheduleRealtimeRetry()
        }

        function scheduleRealtimeRetry() {
          teardownRealtimeConnection()
          if (realtimeState.retryTimer) return
          if (typeof window === 'undefined') return
          realtimeState.retryTimer = window.setTimeout(() => {
            realtimeState.retryTimer = null
            ensureRealtimeConnection()
          }, 5000)
        }

        function teardownRealtimeConnection() {
          if (realtimeState.source) {
            try {
              realtimeState.source.removeEventListener('message', handleRealtimeEvent)
              realtimeState.source.removeEventListener('error', handleRealtimeError)
              realtimeState.source.close()
            } catch (_) {
              /* noop */
            }
            realtimeState.source = null
          }
        }
        if (typeof window !== 'undefined') {
          window.addEventListener('beforeunload', () => {
            if (realtimeState.retryTimer) {
              window.clearTimeout(realtimeState.retryTimer)
              realtimeState.retryTimer = null
            }
            teardownRealtimeConnection()
          })
        }

        function handleRealtimeMatchConfirmed(entry) {
          if (!entry || !currentTargetProfile?.id) return
          const targetId = String(entry.targetId || '').trim()
          const viewerId = String(currentTargetProfile.id || '').trim()
          if (!targetId || targetId !== viewerId) return
          const candidateKey = normalizeCandidateKey(entry.candidateId)
          if (!candidateKey) return
          const extraMatch =
            entry.extraMatch !== undefined
              ? Boolean(entry.extraMatch) || isExtraMatchCandidate(candidateKey)
              : isExtraMatchCandidate(candidateKey)
          const contact = {
            name: entry.candidateName || '',
            phone: entry.candidatePhone || '',
            phoneMasked: entry.candidatePhoneMasked || maskPhoneNumber(entry.candidatePhone),
          }
          matchState.confirmedById.set(candidateKey, contact)
          matchState.contactById.set(candidateKey, contact)
          matchedCandidateIds.add(candidateKey)
          let pendingChanged = false
          if (pendingSelectionSet.delete(candidateKey)) {
            pendingChanged = true
          }
          if (pendingChanged && lastLookupPhoneKey) {
            savePendingSelections(lastLookupPhoneKey, pendingSelectionSet)
          }
          const buttons = findCandidateButtons(candidateKey)
          if (buttons.length) {
            buttons.forEach((button) => {
              const cancelButton = getCancelButton(button)
              markMatchButtonCompleted(button, {
                mutual: true,
                contact,
                cancelButton,
                matchEntryId: entry.id,
                extraMatch,
              })
              const wrapper = button.closest('.match-card')
              if (extraMatch && wrapper) {
                wrapper.classList.add('match-card-extra')
              }
              revealMatchCard(wrapper)
            })
          }
          if (extraMatch) {
            persistIncomingRequestUpdate(candidateKey, { status: 'confirmed' })
          }
        }

        function findCandidateButtons(candidateId) {
          if (!candidateId) return []
          const selectorValue = escapeAttributeValue(candidateId)
          return Array.from(
            document.querySelectorAll(`.match-card-select-btn[data-candidate-id="${selectorValue}"]`),
          )
        }

        function escapeAttributeValue(value) {
          return String(value || '').replace(/"/g, '\\"')
        }

        function escapeHtml(str) {
          return String(str || '')
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;')
        }
      })()
    </script>
  </body>
</html>


